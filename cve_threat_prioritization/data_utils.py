import pandas as pd
import os
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import IsolationForest

from cve_threat_prioritization import config

import warnings
# ignore warnings from scikit-learn
warnings.simplefilter(action='ignore', category=UserWarning)
warnings.simplefilter(action='ignore', category=FutureWarning)


def set_variable_title(variable):
    return ' '.join(word.capitalize() for word in variable.split('_'))


def set_variable_titles_dict(variables_list):
    variable_title_dict = {}
    for variable in variables_list:
        variable_title_dict[variable] = set_variable_title(variable)

    return variable_title_dict


def load_data():
    data_df = pd.read_csv(os.path.join(config._DATA_DIR, "threat_modeling_features.csv"))
    data_df = data_df.loc[:, ~data_df.columns.str.contains('^Unnamed')]

    return data_df


def get_variables(data_df):
    x = data_df[[col for col in data_df.columns if col in config._THREAT_CLASS_PREDICTION_FEATURES or 'topic' in col]].copy()
    y = data_df[config._THREAT_CLASS_PREDICTION_CLASSES].copy()

    return x, y


def revert_categorical_variable(df, variable, dict_features):
    variable_cols = [
        feature for feature in config._THREAT_CLASS_PREDICTION_FEATURES if variable in feature
    ]
    df.loc[:, variable] = df[variable_cols].idxmax(axis=1)
    df.loc[:, variable] = df[variable].str.replace(f'{variable}_', '')
    df = df.drop(columns=variable_cols)
    dict_features[variable] = set_variable_title(variable)

    return df


def convert_binary2bool(df, variable):
    df.loc[:, variable] = df[variable].astype(bool)

    return df


def describe_variable(df, variable):
    print(df[variable].describe())


def plot_categorical_feature(df, feature, title=None, order=None):
    sns.set(style="whitegrid")
    plt.figure(figsize=(10, 6))

    ax = sns.countplot(x=feature, data=df, order=order, palette="Set2")

    total = len(df[feature])

    for p in ax.patches:
        percentage = f'{100 * p.get_height() / total:.1f}%'
        x_position = p.get_x() + p.get_width() / 2
        y_position = p.get_height()
        ax.annotate(percentage, (x_position, y_position), ha='center', va='bottom', fontsize=14)

    plt.xlabel(feature, fontsize=16)
    plt.ylabel("Count", fontsize=16)
    if title:
        plt.title(title, fontsize=20)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)

    plt.show()
    plt.close()


def plot_hist_plot(df, feature, title=None):
    sns.set(style="whitegrid")
    plt.figure(figsize=(10, 6))

    sns.histplot(x=feature, data=df, palette="Set2", kde=True)

    plt.xlabel(feature, fontsize=16)
    plt.ylabel("Count", fontsize=16)
    if title:
        plt.title(title, fontsize=20)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)

    plt.show()
    plt.close()


def plot_boxplot(df, feature, title=None):
    sns.set(style="whitegrid")
    plt.figure(figsize=(10, 9))

    sns.boxplot(x=feature, data=df, palette="Set2")
    plt.xlabel(feature, fontsize=16)
    plt.ylabel("Count", fontsize=16)
    if title:
        plt.title(title, fontsize=20)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)

    plt.show()
    plt.close()


def plot_numeric_feature(df, feature, title=None):
    plot_hist_plot(df, feature, title)
    plot_boxplot(df, feature, title)


def apply_log_transformation(df, variable):
    df[f'{variable}_log'] = np.log1p(df[variable])

    return df


def run_ks_normality_test(df, variable):
    stat, p_value = stats.kstest(df[variable], 'norm')
    if p_value < 0.05:
        print(f"{variable} is not normally distributed.")
    else:
        print(f"{variable} is normally distributed.")


def apply_minmax_normalization(df, variable):
    variable_minmax_scaler = MinMaxScaler()
    df[f'{variable}_minmax'] = variable_minmax_scaler.fit_transform(df[[variable]])

    return df, variable_minmax_scaler


def apply_isolation_forest_outlier_detection(df, variable):

    clf = IsolationForest(contamination=0.05)
    outliers = clf.fit_predict(df[[variable]]) == -1
    print(f"Percentage of outliers: {100 * outliers.sum() / len(outliers):.2f}%")

    return outliers


def get_categorical_variables(df):
    return df.select_dtypes(include=['object', 'category', 'bool']).columns.tolist()
